\documentclass[a4paper,12pt]{report}
\usepackage{algorithmic}
\usepackage[T1]{fontenc} 
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage[margin=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{listings} 
\usepackage{graphicx} 
\usepackage{color}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{verbatim}

\newcommand{\currentdata}{14 February 2015}
\newtheorem{example}{Example}

\begin{document}
\vspace{-5cm}
\begin{center}
Department of Computer Science\\
Technical University of Cluj-Napoca\\
\includegraphics[width=10cm]{fig/footer}
\end{center}
\vspace{1cm}
\begin{center}
\begin{Large}
 \textbf{Artificial Intelligence}\\
\end{Large}
\textit{Laboratory activity}\\
\vspace{3cm}
Name: Flanja Tudor Calin\\
Group: 30434\\
Email: tudorflanja@gmail.com\\
\vspace{12cm}
Teaching Assistant: Adrian Groza\\
Adrian.Groza@cs.utcluj.ro\\
\vspace{1cm}
\includegraphics[width=10cm]{fig/footer}
\end{center}

\tableofcontents


\chapter{A1: Search}
\section{Introduction}
The Snake game is a classic and iconic arcade game in which the player controls a growing snake that moves around a confined playing area. The objective is to eat food items that appear on the screen to make the snake longer while avoiding collisions with the walls of the playing area and, more importantly, with its own tail. As the snake grows, the game becomes increasingly challenging, testing the player's reflexes and spatial awareness. The goal is to achieve the highest score possible by collecting food items and maneuvering the snake without running into obstacles. In our project we removed the collision of the snake with the walls.
\section{Developement}
\subsection{Track the food relative to the head}
In this step we gave the snake the ability to control it's movement by getting rid of the players ability to control it using the arrow keys. We repurposed the "handle\_keys" function. Then we got the head position which is gonna tell us where the head of the snake is in x and y coordinates and we compared that to the food's position. In this stage the AI is going to make sure the snake understands where its head is relative to the food and pursue it, to figure out how to get closer to it. We created a tuple variable "distance", a two-dimensional vector, that's going to tell us how far from the food in the x and y direction we are. The snake is going to pursue the food in the most direct way it possibly can, but at the risk of its own body. The average score at which the snake dies is around 20 points.
\subsection{Don't allow the snake to turn into itself}
We wanted to go a step further in which the snake can't turn into it's own body. Basically, it will only make a turn if it's not going to hit itself. What we want to do is to come into the "if" statements for all of our distances and add a "check" to make sure it won't turn into itself. We want to add another condition before it turns left, right, up and down. The most common way we were dying before this implementation was not actually turning into our own body but is was not turning away when we hit our own body. The average score at which the snake dies is around 23 points.
\subsection{Turn away before colliding with body}
In this step the snake is going to be turning out of the way when it senses that the spot it's moving into is occupied by it's body. We want to create a new loop every time we check this. We declare a variable that we will use locally, "colliding". For example, if we are heading down and the square bellow is occupied, then we will set the "colliding" variable to "DOWN". This applies also to UP, LEFT and RIGHT. Now that we know if the snake is colliding, we need it to make the decision to turn out of it. To do that we will go where we we're already controlling whether to make a turn. The snake is dying at this stage because it's not calculating whether it was a better decision to move in the other direction.
\subsection{Determine which available turn is better}
We created 4 variables left\_gap, right\_gap, top\_gap, bot\_gap in which 
we will store the distance between the head of the snake and it's body, 
in all directions possible. We want to keep track of the closest position
to the head. The code is shown below for one of the cases: 
\begin{verbatim}
if(head[0],head[1]-(i*GRID_SIZE)) in self.positions:
		if top_gap<i:
			top_gap=i
\end{verbatim}
We also added one more condition for how the snake chooses to take a turn. 
For example, the snake will turn left only when all the previous conditions
are passed and in addition, the left\_gap is bigger than the one on the right
(greater or equal, in case of the same distance, it is irrelevant).
\chapter{A2: Logics}

\section{Introduction}
Welcome to the world of First-Order Logic (FOL) logic puzzles! These puzzles are fascinating challenges that require a keen understanding of logical reasoning and deduction. FOL, a fundamental component of mathematical logic, serves as the backbone for these brain-teasers, offering an engaging and thought-provoking way to exercise cognitive abilities.\newline \newline
FOL puzzles present scenarios where you, as the solver, must apply logical rules and deductions to unravel intricate relationships, constraints, and patterns. They are designed to test your ability to make precise and systematic inferences based on given information, ultimately arriving at a logically consistent solution. \newline \newline
In this documentation, we dive into the fundamentals of FOL logic puzzles, providing you with a comprehensive understanding of their structure, rules, and solving strategies, applied in the next 4 puzzles.\newline \newline
The command to run the ``Placings'' puzzle is ``prover9 -f placings'' and for the rest of them is ``mace4 -f nameOfFile''. The first puzzle is run with Prover9 because it generates a large model and Mace4 does not have the ``power'' to perform the task and the model is generated in the ``placings.out'' file.

\section{Logic puzzles}
\subsection{Placings}
\subsubsection{\Large Task}
List the order in which each person finished.
\begin{enumerate}
    \item Tommy Tombstone finished after Lance Lamers and Brett Brown but before Mitch Monday.
    \item Peter Poultry finished before Daniel Dusk and Lance Lamers.
    \item Sam Sunny finished after Peter Poultry and before Jack Jill and Harry Hills.
    \item Keri Kernel finished after Peter Poultry, Mitch Monday and Tommy Tombstone.
    \item Lance Lamers finished after Brett Brown and Daniel Dusk, but before Jack Jill and Mitch Monday.
    \item Mitch Monday finished after Sam Sunny and Brett Brown.
    \item Brett Brown finished before Jack Jill, Mitch Monday and Peter Poultry.
    \item Daniel Dusk finished before Keri Kernel and Tommy Tombstone, but after Sam Sunny.
    \item Jack Jill finished before Keri Kernel, Tommy Tombstone and Mitch Monday, but after Peter Poultry and Daniel Dusk.
    \item Harry Hills finished before Mitch Monday but after Lance Lamers, Jack Jill and Tommy Tombstone.
\end{enumerate}

\subsubsection{\Large Solving}
The code for this task is provided in the Appendix part of the project. This section of the documentation will cover only the explanations. 
\subsubsection{Prerequisites}
The code provided represents a logical puzzle formulated in First-Order Logic (FOL) to determine the order in which a group of individuals finished a race. The task involves deducing the order of completion based on a set of clues and constraints provided.

\subsubsection{Clues and Constraints}
\begin{enumerate}
\item  \textbf{Differentiation}: The different predicate establishes that each person is distinct from the others. This ensures uniqueness in the order of finish.
\item \textbf{Succession}: The next predicate denotes the sequential relationship between individuals. It defines the order in which one person finished immediately before another.
\item  \textbf{Individual Assignment}: Each person is assigned to one and only one position in the finishing order. This is represented by predicates like TommyTombstone(x), LanceLamers(x), etc.
\item \textbf{Task Rules}: These rules express the relationships and order constraints derived from the given statements about the finishing positions of the individuals.
\end{enumerate}

\subsubsection{Solution}

The provided FOL logic translates the verbal clues into logical statements, linking the individuals' finishing positions:
\begin{itemize}
    \item The task rules (labeled 1 to 10) represent the deductions derived from the verbal statements about the order in which people finished relative to each other.
    \item Succession: The next predicate denotes the sequential relationship between individuals. It defines the order in which one person finished immediately before another.
    \item Individual Assignment: Each person is assigned to one and only one position in the finishing order. This is represented by predicates like TommyTombstone(x), LanceLamers(x), etc. 
    \item Task Rules: These rules express the relationships and order constraints derived from the given statements about the finishing positions of the individuals.
\end{itemize}

\subsection{First and Last Names}
\subsubsection{\Large Task}
The first names of five people are Beverly, Charles, Monica, Nelson, and Ruth. Their last names are Atwood, Porter, Stafford, Thompson, and Ward. Match each person first and last names.

\begin{enumerate}
    \item Ruth and Porter went hiking yesterday with Monica and Stafford.
    \item Beverly enrolled her son, and Atwood enrolled her daughter, at the same nursery school.
    \item Thompson and Ruth don't have children.
    \item Charles, who has been in the hospital for the past three days, was visited today by Porter and Nelson.
\end{enumerate}

\subsubsection{\Large Solving}
The code for this task is provided in the Appendix part of the project. This section of the documentation will cover only the explanations. 
\subsubsection{Prerequisites}
The code represents a logical puzzle where the objective is to match the first and last names of five people: Beverly, Charles, Monica, Nelson, and Ruth. Each person is associated with one first name and one last name from the set of possible options: Atwood, Porter, Stafford, Thompson, and Ward.

\subsubsection{Clues and Constraints}
\begin{enumerate}
\item  \textbf{Hiking Companions}: Monica and Ruth went hiking yesterday. Deduction: Monica and Ruth did not have the last names Porter or Stafford due to their hiking companionship.
\item \textbf{Enrollment at Nursery School}: Beverly and Atwood enrolled their children in the same nursery school. Deduction: Beverly's last name cannot be Atwood.
\item  \textbf{Children Status}: Thompson and Ruth do not have children. Deduction: Eliminates certain last name possibilities for Thompson and Ruth.
\item \textbf{Hospital Visit}: Charles, who has been hospitalized, was visited by Porter and Nelson. Deduction: Charles's last name cannot be Porter, and Nelson's last name also cannot be Porter or Stafford.
\item \textbf{Gender Differentiation}: Charles and Nelson are males; the others are female. Deduction: Certain last names are eliminated for Charles and Nelson based on the gender differentiation.
\end{enumerate}

\subsubsection{Solution}

The FOL logic rules eliminate potential combinations of first and last names based on the clues provided. These rules are used to create constraints that determine which combinations are valid or invalid according to the given information.

\begin{figure}[h]
\includegraphics[width=15cm]{firstAndLastNames.png}
\centering
\caption{Mace4 demonstration for the problem}
\end{figure}

\subsection{Toddlers and Teddies}
\subsubsection{\Large Task}
At the local play group for babies and toddlers, I was asking the mothers about the number of teddies each of their children has.

\begin{enumerate}
    \item The four children are aged 1, 2, 3 and 4.
    \item Remarkably, the children have one, two, three and four teddies, although not necessarily respectively.
    \item James has more teddies than his age. 
    \item John is older than Matthew.
    \item Curiously only one child has the same number of teddies as his age.
    \item Paul has less teddies than John, and the child aged 3 has two teddies.
    \item Paul is the youngest. 
\end{enumerate}
How old is each child and how many teddies do they have each?

\subsubsection{\Large Solving}
The code for this task is provided in the Appendix part of the project. This section of the documentation will cover only the explanations. 
\subsubsection{Prerequisites}
The code encapsulates a logical puzzle concerning the number of teddies each child, aged 1, 2, 3, and 4, has at a local playgroup. The children's names are James, John, Matthew, and Paul.

\subsubsection{Clues and Constraints}
\begin{enumerate}
\item  \textbf{Teddies and Ages}: Each child has a unique number of teddies, ranging from 1 to 4, but not necessarily in ascending order. James has more teddies than his age, and only one child has the same number of teddies as their age.
\item \textbf{Age Relations}: John is older than Matthew. The child aged 3 has two teddies, and Paul is the youngest.
\end{enumerate}

\subsubsection{Solution}

The deductions made based on the clues are as follows:
\begin{enumerate}
    \item Paul is the youngest, so he is 1 year old.
    \item James has more teddies than his age, indicating he's either 2 or 3 years old.
    \item John being older than Matthew, and Paul being 1 year old, limits Matthew to 2 or 3 years old, and John to 3 or 4 years old.
    \item The child aged 3 (Matthew) has two teddies, excluding James from being 3 years old. James is 2 years old.
    \item John, being older than Matthew, becomes 4 years old, leaving Matthew as 3 years old.
\end{enumerate}
Using these deductions, the code assigns each child's age and the number of teddies they have accordingly: Paul is 1 year old with 1 teddy, James is 2 years old with 4 teddies, Matthew is 3 years old with 2 teddies, and John is 4 years old with 3 teddies. This solution satisfies all the given clues and constraints.

\begin{figure}[h]
\includegraphics[width=15cm]{toddlersAndTeddiesSS.png}
\centering
\caption{Mace4 demonstration for the problem}
\end{figure}

\subsection{Books, books and more books}
\subsubsection{\Large Task}
Jake, John, Joe, and Jack each have a different favorite book series. These include "Harry Potter", "The Lord of the Rings", "Sherlock Holmes", and "The Hardy Boys". Using the clues, figure out who likes which book series.

\begin{enumerate}
    \item Jake and Joe love mysteries, while John and Jack prefer magic and fantasy.
    \item "Joe" is the name of a character in Joe's favorite series. 
    \item John's Halloween costume, based on his favorite series, includes glasses and a black robe.
\end{enumerate}

\subsubsection{\Large Solving}
The code for this task is provided in the Appendix part of the project. This section of the documentation will cover only the explanations. 
\subsubsection{Prerequisites}
The code presents a logic puzzle where four individuals, Jake, John, Joe, and Jack, have distinct favorite book series: "Harry Potter," "The Lord of the Rings," "Sherlock Holmes," and "The Hardy Boys."

\subsubsection{Clues and Constraints}
\begin{enumerate}
\item  \textbf{Genre Preferences}: Jake and Joe favor mystery series ("Sherlock Holmes" or "The Hardy Boys"), while John and Jack prefer magical and fantasy series ("Harry Potter" or "The Lord of the Rings").
\item \textbf{Character Reference}: "Joe" is a character in Joe's favorite series ("The Hardy Boys").
\item \textbf{Halloween Costume}: John's Halloween costume, based on his favorite series, involves glasses and a black robe (indicative of "Harry Potter").
\end{enumerate}
\subsubsection{Solution}

Using these deductions, the code assigns each individual to their respective favorite book series: Jake favors "Sherlock Holmes," John prefers "Harry Potter," Joe's favorite is "The Hardy Boys," and Jack's preference is "The Lord of the Rings." This solution aligns with all the provided clues and constraints.

\begin{figure}[h]
\includegraphics[width=15cm]{booksSS.png}
\centering
\caption{Mace4 demonstration for the problem}
\end{figure}
\newpage

\section{Graphical User Interface}

\subsection{User Interface Features}
The user interface presents a window with four buttons, each associated with a logic puzzle. Clicking a button displays the puzzle's description and prompts users to reveal the solution.

\subsection{Displaying Text}
The \texttt{display\_text()} function shows the puzzle description and the answer when the associated button is clicked. It uses Tkinter's Label and Button widgets.

\subsection{Button Functions}
Each button is linked to a specific puzzle and calls a corresponding function when clicked (\texttt{button1\_clicked()}, \texttt{button2\_clicked()}, etc.).

\subsection{Conclusion}
The user interface provides an interactive way to solve logic puzzles by displaying the puzzle descriptions and their solutions upon button click.

\subsection{GUI}
\begin{figure}[h]
\includegraphics[width=15cm]{placingsGUI.png}
\centering
\caption{GUI for ``Placings'' problem}
\end{figure}

\begin{figure}[h]
\includegraphics[width=15cm]{firstLastNamesGUI.png}
\centering
\caption{GUI for ``First and Last Names'' problem}
\end{figure}

\begin{figure}[h]
\includegraphics[width=15cm]{toddlersAndTeddiesGUI.png}
\centering
\caption{GUI for ``Toddlers and Teddies'' problem}
\end{figure}

\begin{figure}[h]
\includegraphics[width=15cm]{booksGUI.png}
\centering
\caption{GUI for ``Books, books and more books'' problem}
\end{figure}

\chapter{A3: Planning}

\bibliographystyle{plain}
\bibliography{is}
1-st Assignment:\newline \newline
\href{URL}{https://en.wikipedia.org/wiki/Snake\_(video\_game\_genre)}\\
\href{URL}{https://www.youtube.com/watch?v=kqtD5dpn9C8}\\
\href{URL}{https://www.youtube.com/watch?v=56bPIGf4us0}\newline \newline
2-nd Assignment:\newline \newline
\href{URL}{https://www.braingle.com/brainteasers/29710/first-and-last-names.html}\\
\href{URL}{https://www.braingle.com/brainteasers/36278/placings.html}\\
\href{URL}{https://www.braingle.com/brainteasers/3598/toddlers-and-teddies.html}\\
\href{URL}{https://www.braingle.com/brainteasers/44631/books-books-and-more-books.html}\\
\href{URL}{https://moodle.cs.utcluj.ro/course/view.php?id=620}\\
\href{URL}{https://www.javatpoint.com/first-order-logic-in-artificial-intelligence}\\
\appendix

\chapter{Your original code}
\section{1-st Assignment}
\begin{verbatim}
import pygame
import sys
import random

pygame.init()

class Snake(object):
def _init_(self):
    self.length = 1
    self.positions = [((WIDTH / 2), (HEIGHT / 2))]
    self.direction = random.choice([UP, DOWN, LEFT, RIGHT])
    self.color = black

def get_head_position(self):
    return self.positions[0]

def turn(self, point):
    if self.length > 1 and (point[0] * -1, point[1] * -1) == self.direction:
        return
    else:
        self.direction = point

def move(self):
cur = self.get_head_position()
x, y = self.direction
new = (((cur[0] + (x * GRID_SIZE)) % WIDTH), (cur[1] + (y * GRID_SIZE)) % HEIGHT)
if len(self.positions) > 2 and new in self.positions[2:]:
        self.reset()
    else:
        self.positions.insert(0, new)
        if len(self.positions) > self.length:
            self.positions.pop()

    def reset(self):
        self.length = 1
        self.positions = [((WIDTH / 2), (HEIGHT / 2))]
        self.direction = random.choice([UP, DOWN, LEFT, RIGHT])

def draw(self, surface):
    for p in self.positions:
        r = pygame.Rect((p[0], p[1]), (GRID_SIZE, GRID_SIZE))
        pygame.draw.rect(surface, self.color, r)
        pygame.draw.rect(surface, black, r, 1)

def handle_keys(self,food_pos):
    head=self.get_head_position()
    distance=(head[0]-food_pos[0],head[1]-food_pos[1])

    left_gap = 100
    right_gap = 100
    top_gap = 100
    bot_gap = 100

    for i in range(1, int(GRID_WIDTH)):
        if (head[0], head[1] - (i * GRID_SIZE)) in self.positions:
            if top_gap < i:
                top_gap = i
        if (head[0], head[1] + (i * GRID_SIZE)) in self.positions:
            if bot_gap < i:
                bot_gap = i
        if (head[0] - (i * GRID_SIZE), head[1]) in self.positions:
            if left_gap < i:
                left_gap = i
        if (head[0] + (i * GRID_SIZE), head[1]) in self.positions:
            if right_gap < i:
                right_gap = i
colliding=''
if self.direction==DOWN and (head[0],head[1]+GRID_SIZE) in self.positions:
        colliding='down'
if self.direction==UP and (head[0],head[1]-GRID_SIZE) in self.positions:
        colliding='up'
if self.direction==LEFT and (head[0]-GRID_SIZE,head[1]) in self.positions:
        colliding='left'
if self.direction==RIGHT and (head[0]+GRID_SIZE,head[1]) in self.positions:
        colliding='right'

if (distance[0]>0 or ((colliding=='up' or colliding=='down') and 
left_gap>=right_gap)) and (head[0]-GRID_SIZE,head[1]) not in self.positions:
        self.turn(LEFT)
if (distance[0]<0 or ((colliding=='up' or colliding=='down') and 
right_gap>left_gap)) and (head[0]+GRID_SIZE,head[1]) not in self.positions:
        self.turn(RIGHT)
if (distance[1] > 0 or ((colliding=='left' or colliding=='right') and 
top_gap>=bot_gap)) and (head[0],head[1]-GRID_SIZE) not in self.positions:
        self.turn(UP)
if (distance[1] < 0 or ((colliding=='left' or colliding=='right') and 
bot_gap>top_gap)) and (head[0],head[1]+GRID_SIZE) not in self.positions:
        self.turn(DOWN)
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
             # elif event.type == pygame.KEYDOWN:
             #    if event.key == pygame.K_UP:
             #        self.turn(UP)
             #    elif event.key == pygame.K_DOWN:
             #        self.turn(DOWN)
             #    elif event.key == pygame.K_LEFT:
             #        self.turn(LEFT)
             #    elif event.key == pygame.K_RIGHT:
             #        self.turn(RIGHT)


class Food(object):
def _init_(self):
    self.position = (0, 0)
    self.color = red
    self.randomize_position()

def randomize_position(self):
self.position = (random.randint(0, GRID_WIDTH - 1) * GRID_SIZE, 
random.randint(0, GRID_HEIGHT - 1) * GRID_SIZE)

def draw(self, surface):
    r = pygame.Rect((self.position[0], self.position[1]), (GRID_SIZE, GRID_SIZE))
    pygame.draw.rect(surface, self.color, r)
    pygame.draw.rect(surface, black, r, 1)


def drawGrid(surface):
for y in range(0, int(GRID_HEIGHT)):
    for x in range(0, int(GRID_WIDTH)):
        if ((x + y) % 2) == 0:
        r = pygame.Rect((x * GRID_SIZE, y * GRID_SIZE), (GRID_SIZE, GRID_SIZE))
        pygame.draw.rect(surface, gray1, r)
        else:
        rr = pygame.Rect((x * GRID_SIZE, y * GRID_SIZE), (GRID_SIZE, GRID_SIZE))
        pygame.draw.rect(surface, gray2, rr)


WIDTH = 480
HEIGHT = 480
gray1 = (120, 120, 120)
gray2 = (170, 170, 170)
red = (200, 40, 40)
green = (20, 200, 50)
black = (0, 0, 0)
GRID_SIZE = 20
GRID_WIDTH = WIDTH / GRID_SIZE
GRID_HEIGHT = HEIGHT / GRID_SIZE

UP = (0, -1)
DOWN = (0, 1)
LEFT = (-1, 0)
RIGHT = (1, 0)
font = pygame.font.Font('freesansbold.ttf', 30)


def main():
    pygame.init()

    clock = pygame.time.Clock()
    screen = pygame.display.set_mode((WIDTH, HEIGHT), 0, 32)

    surface = pygame.Surface(screen.get_size())
    surface = surface.convert()
    drawGrid(surface)

    snake = Snake()
    food = Food()

    score = 0
    while True:
        clock.tick(15)
        snake.handle_keys(food.position)
        drawGrid(surface)
        snake.move()
        if snake.get_head_position() == food.position:
            snake.length += 1
            score += 1
            food.randomize_position()
        snake.draw(surface)
        food.draw(surface)
        screen.blit(surface, (0, 0))
        text = font.render("Score {0}".format(score), True, black)
        screen.blit(text, (5, 10))
        pygame.display.update()


main()
\end{verbatim}
\section{2-nd Assignment}
The code shown below is for the "First and Last Names" puzzle:
\begin{verbatim}
set(arithmetic).  
assign(domain_size, 5).

list(distinct).

[Beverly, Charles, Monica, Nelson, Ruth].
[Atwood, Porter, Stafford, Thompson, Ward].

end_of_list.

formulas(assumptions). 

	Beverly = 0.
	Charles = 1.
	Monica = 2.
	Nelson = 3.
	Ruth = 4.
	
	%Clue 1. Monica's and Ruth's last name is not Porter, neither Stafford 
%because they went hiking together 
	Monica != Porter.
	Monica != Stafford.
	Ruth != Porter.
	Ruth != Stafford.
	
	%Clue 2. Beverly's last name is not Atwood, because both have enrolled their 
%child to the nursery school

	%Atwood can not be a male
	Beverly != Atwood.

	%Clue 3. 
	Beverly != Thompson.
	Ruth != Atwood.
	Ruth != Thompson.
	
	%Clue 4. Charles's last name is not Porter, because he was visited in the 
%hospital by him
	Charles != Porter.
	Nelson != Porter.
	Charles != Stafford.
	
	%Clue 5
	Charles != Atwood.
	Nelson != Atwood.

end_of_list.
\end{verbatim}

The code shown bellow is for the "Placings" puzzle:
\begin{verbatim}
formulas(assumptions).
 
 different(person1,person2).
 different(person1,person3).
 different(person1,person4).
 different(person1,person5).
 different(person1,person6).
 different(person1,person7).
 different(person1,person8).
 different(person1,person9).
 different(person1,person10).
 
 different(person2,person3).
 different(person2,person4).
 different(person2,person5).
 different(person2,person6).
 different(person2,person7).
 different(person2,person8).
 different(person2,person9).
 different(person2,person10).
 
 different(person3,person4).
 different(person3,person5).
 different(person3,person6).
 different(person3,person7).
 different(person3,person8).
 different(person3,person9).
 different(person3,person10).
 
 different(person4,person5).
 different(person4,person6).
 different(person4,person7).
 different(person4,person8).
 different(person4,person9).
 different(person4,person10).
 
 different(person5,person6).
 different(person5,person7).
 different(person5,person8).
 different(person5,person9).
 different(person5,person10).
 
 different(person6,person7).
 different(person6,person8).
 different(person6,person9).
 different(person6,person10).
 
 different(person7,person8).
 different(person7,person9).
 different(person7,person10).
 
 different(person8,person9).
 different(person8,person10).
 
 different(person9,person10).
 
 different(x,y) -> different(y,x).
 
 %next
 
-next(person1, person1).
-next(person2, person2).
-next(person3, person3).
-next(person4, person4).
-next(person5, person5).
-next(person6, person6).
-next(person7, person7).
-next(person8, person8).
-next(person9, person9).
-next(person10, person10).
 
 next(person1, person2).
-next(person1, person3).
-next(person1, person4).
-next(person1, person5).
-next(person1, person6).
-next(person1, person7).
-next(person1, person8).
-next(person1, person9).
-next(person1, person10).

 next(person2, person3).
-next(person2, person4).
-next(person2, person5).
-next(person2, person6).
-next(person2, person7).
-next(person2, person8).
-next(person2, person9).
-next(person2, person10).

 next(person3, person4).
-next(person3, person5).
-next(person3, person6).
-next(person3, person7).
-next(person3, person8).
-next(person3, person9).
-next(person3, person10).

 next(person4, person5).
-next(person4, person6).
-next(person4, person7).
-next(person4, person8).
-next(person4, person9).
-next(person4, person10).

 next(person5, person6).
-next(person5, person7).
-next(person5, person8).
-next(person5, person9).
-next(person5, person10).

 next(person6, person7).
-next(person6, person8).
-next(person6, person9).
-next(person6, person10).

 next(person7, person8).
-next(person7, person9).
-next(person7, person10).

 next(person8, person9).
-next(person8, person10).

next(person9, person10).

-next(person2, person1).
-next(person3, person1).
-next(person4, person1).
-next(person5, person1).
-next(person6, person1).
-next(person7, person1).
-next(person8, person1).
-next(person9, person1).
-next(person10, person1).

-next(person3, person2).
-next(person4, person2).
-next(person5, person2).
-next(person6, person2).
-next(person7, person2).
-next(person8, person2).
-next(person9, person2).
-next(person10, person2).

-next(person4, person3).
-next(person5, person3).
-next(person6, person3).
-next(person7, person3).
-next(person8, person3).
-next(person9, person3).
-next(person10, person3).

-next(person5, person4).
-next(person6, person4).
-next(person7, person4).
-next(person8, person4).
-next(person9, person4).
-next(person10, person4).

-next(person6, person5).
-next(person7, person5).
-next(person8, person5).
-next(person9, person5).
-next(person10, person5).

-next(person7, person6).
-next(person8, person6).
-next(person9, person6).
-next(person10, person6).

-next(person8, person7).
-next(person9, person7).
-next(person10, person7).

-next(person9, person8).
-next(person10, person8).

-next(person10, person9).

%next(x, y) -> next(y, x).

TommyTombstone(x) | LanceLamers(x) | BrettBrown(x) | MitchMonday(x) | PeterPoultry(x)
| DanielDusk(x) | SamSunny(x) | JackJill(x) | HarryHills(x) | KeriKernel(x).

TommyTombstone(x) & TommyTombstone(y) -> -different(x, y).
LanceLamers(x) & LanceLamers(y) -> -different(x, y).
BrettBrown(x) & BrettBrown(y) -> -different(x, y).
MitchMonday(x) & MitchMonday(y) -> -different(x, y).
PeterPoultry(x) & PeterPoultry(y) -> -different(x, y).
DanielDusk(x) & DanielDusk(y) -> -different(x, y).
SamSunny(x) & SamSunny(y) -> -different(x, y).
JackJill(x) & JackJill(y) -> -different(x, y).
HarryHills(x) & HarryHills(y) -> -different(x, y).
KeriKernel(x) & KeriKernel(y) -> -different(x, y).

%tasks

%1
LanceLamers(x) & TommyTombstone(y) -> next(x,y).
BrettBrown(x) & TommyTombstone(y) -> next(x,y).
TommyTombstone(x) & MitchMonday(y) -> next(x,y).

%2
PeterPoultry(x) & DanielDusk(y) -> next(x,y).
PeterPoultry(x) & LanceLamers(y) -> next(x,y).

%3
PeterPoultry(x) & SamSunny(y) -> next(x,y).
SamSunny(x) & JackJill(y) -> next(x,y).
SamSunny(x) & HarryHills(y) -> next(x,y).

%4
PeterPoultry(x) & KeriKernel(y) -> next(x,y).
MitchMonday(x) & KeriKernel(y) -> next(x,y).
TommyTombstone(x) & KeriKernel(y) -> next(x,y).

%5
BrettBrown(x) & LanceLamers(y) -> next(x,y).
DanielDusk(x) & LanceLamers(y) -> next(x,y).
LanceLamers(x) & JackJill(y) -> next(x,y).
LanceLamers(x) & MitchMonday(y) -> next(x,y).

%6
SamSunny(x) & MitchMonday(y) -> next(x,y).
BrettBrown(x) & MitchMonday(y) -> next(x,y).

%7
BrettBrown(x) & JackJill(y) -> next(x,y).
BrettBrown(x) & MitchMonday(y) -> next(x,y).
BrettBrown(x) & PeterPoultry(y) -> next(x,y).

%8
DanielDusk(x) & KeriKernel(y) -> next(x,y).
DanielDusk(x) & TommyTombstone(y) -> next(x,y).
SamSunny(x) & DanielDusk(y) -> next(x,y).

%9
JackJill(x) & KeriKernel(y) -> next(x,y).
JackJill(x) & TommyTombstone(y) -> next(x,y).
JackJill(x) & MitchMonday(y) -> next(x,y).
PeterPoultry(x) & JackJill(y) -> next(x,y).
DanielDusk(x) & JackJill(y) -> next(x,y).

%10
HarryHills(x) & MitchMonday(y) -> next(x,y).
LanceLamers(x) & HarryHills(y) -> next(x,y).
JackJill(x) & HarryHills(y) -> next(x,y).
TommyTombstone(x) & HarryHills(y) -> next(x,y).
\end{verbatim}

The code shown bellow is for the "Toddlers and Teddies" puzzle:
\begin{verbatim}
set(arithmetic).  
assign(domain_size, 4).

list(distinct).

[James, John, Matthew, Paul].
[t1, t2, t3, t4].

end_of_list.

formulas(assumptions).

%Paul is the youngest, so he is 1 year old
%James has more teddies than his age and Paul is 1 year old, so James can be either 
%2 or 3 years old
%John being older than Matthew and Paul being 1 means that Matthew can be only 
%2 or 3 years old and that John can be 3 or 4
%The child aged 3 has two teddies, so that he can't be James so it's either 
%John or Matthew -> James is 2 years old
%There remains two toddlers without an age assigned and they are John and Matthew. 
%John being older than Matthew, it means that Matthew is 3 and John is 4
Paul = 0.
James = 1. 
Matthew = 2. 
John = 3.

%Child aged 3(Matthew) has 2 teddies
Matthew = t2.

%James(being 2) can have either 3 or 4 teddies
James = t3 | James = t4.

%Matthew and James both having a number of teddies different to their age, it remains 
%that Paul and John have the same number of teddies as their age
Paul = t1 | John = t4.

%If Paul has 3 teddies, then John will have 4 teddies and James 1 that will be in 
%contradiction with this statement: "James has more teddies than his age". 
%Paul can't have 4 teddies because that way will have more than John(which is not 
%allowed) That remains that John can't have 4 teddies
John != t4. 
\end{verbatim}

The code shown bellow is for the "Books, Books and more Books" puzzle:
\begin{verbatim}
set(arithmetic).  
assign(domain_size, 4).

list(distinct).

[Jake, John, Joe, Jack].
[HarryPotter, LordRings, SherlockHolmes, HardyBoys].

end_of_list.

formulas(assumptions).

Jake = 0.
John = 1.
Joe = 2.
Jack = 3.

%1. Jake and Joe love mysteries(Sherlock Holmes and The Hardy Boys), 
Jake = SherlockHolmes | Jake = HardyBoys.
Joe = SherlockHolmes | Joe = HardyBoys.
% while John and Jack prefer magic and fantasy(Harry Potter and Lord of the Rings).
John = HarryPotter | John = LordRings.
Jack = HarryPotter | Jack = LordRings.
%2. "Joe" is the name of a character in Joe's favorite series(Joe Hardy in The Hardy 
$boys).
Joe = HardyBoys.
%3. John's Halloween costume, based on his favorite series, includes glasses and a 
%black robe(Harry Potter).
John = HarryPotter.

end_of_list.
\end{verbatim}

\vspace{2cm}
\begin{center}
Intelligent Systems Group\\
\includegraphics[width=10cm]{fig/footer}
\end{center}

\end{document}